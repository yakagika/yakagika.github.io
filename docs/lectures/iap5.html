<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yakagika - 代数プログラミング入門 Ch5 代数的データ型</title>

    <!-- Stylesheets. -->
    <link rel="stylesheet" type="text/css" href="../style.css?v=0">

    <!-- RSS. -->
    <link rel="alternate" type="application/rss+xml" title="yakagika" href="https://yakagika.github.io/rss.xml">

    <!-- Metadata. -->

    <meta name="keywords" content="yakagika Haskell ExchangeAlgebra">
    <meta name="description" content="Personal home page and blog of yakagika.">

    
    <!-- KaTeXのスタイルシートとJavaScriptのリンクを動的に挿入 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <style>
      .katex-display {
        display: block;
        margin: 1em 0;
        text-align: center;
      }
      .katex .frac {
        vertical-align: baseline;
        -webkit-vertical-align: baseline;
      }
      .katex .sqrt {
        vertical-align: baseline;
        -webkit-vertical-align: baseline;
      }
      .katex .strut {
        height: 1em;
        -webkit-height: 1em;
      }
      .katex .base {
        font-family: 'KaTeX_Main', 'Arial', sans-serif;
      }
      @media screen and (-webkit-min-device-pixel-ratio:0) {
        .katex {
          line-height: normal !important;
        }
      }
      @media not all and (min-resolution: .001dpcm) {
        @supports (-webkit-appearance:none) {
          .katex {
            line-height: normal !important;
          }
        }
      }
    </style>
    

    
      <meta property="og:description" content="資料" />
    
  </head>

  <body>

    <!-- ハンバーガーメニューのボタン（小画面時に表示） -->
    <div class="hamburger" onclick="toggleMenu()">☰</div>

    <!-- ナビゲーションに drawer-menu クラスを付与 -->
    <div id="navigation" class="drawer-menu">
      <h1>Contents</h1>
      <a href="../">Home</a>
      <a href="../posts.html">Blog</a>
      <a href="../lectures.html">Lecture</a>
      <a href="../research.html">Research</a>
      <a href="../contact.html">Contact</a>
      <!-- <a href="/cv.html">CV</a> -->

      <h1>Links</h1>
      <a href="http://github.com/yakagika" target="_blank" rel="noopener">GitHub</a>
      <a href="https://researchmap.jp/k-akagi" target="_blank" rel="noopener">researchmap</a>

      
      <div id="lecture-toc">
        <h1>Table of Contents</h1>
        <!-- The TOC will be generated here by JavaScript -->
      </div>
      
    </div>

    <div id="content">
    <h1>代数プログラミング入門 Ch5 代数的データ型</h1>
<div class="soft">
    資料<br />
    Published on 2024-10-18 under the tag <a title="All pages tagged 'algebra'." href="../tags/algebra.html">algebra</a>, <a title="All pages tagged 'lecture'." href="../tags/lecture.html">lecture</a>, <a title="All pages tagged 'statistics'." href="../tags/statistics.html">statistics</a>, <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>
</div>

<!-- 前後の章へのナビゲーション -->
<div class="chapter-navigation">
    <nav>
        
            <a class="nav-link prev" href="iap4.html">← Previous Chapter</a>
        
        
            <a class="nav-link next" href="iap6.html">Next Chapter →</a>
        
    </nav>
</div>

<br>

<h2 id="代数的データ型">代数的データ型</h2>
<p>Haskellのデータ型はすべて代数的データ型です. 代数的データ型には, <strong>列挙型</strong>,<strong>直積型</strong>,<strong>直和型</strong>があり,構文として<strong>レコード構文</strong>などが存在します.</p>
<p>集合論の説明と対応したコードの書き方.
(圏論で書けというのはそのうちやりたい.)</p>
<h3 id="命題と条件式">命題と条件式</h3>
<p>集合を定義するにあたって,数理的な定義の記法に用いる演算子を導入する. 数理的な定義の内,そこで述べられた言説が,「真か偽のいずれかに分類可能とされるもの」を命題といい,条件が与えられた命題を条件式という.</p>
<p><code>x</code>に関する条件式を
<span class="math inline"><em>P</em>(<em>x</em>) ≔  *  * *</span> や <span class="math inline"><em>Q</em>(<em>x</em>)</span>
と書き，<code>***</code>の部分に,命題が記述される．</p>
<p>命題の記述には以下の論理演算子が用いられる．</p>
<ul>
<li><p><span class="math inline"><em>P</em>(<em>x</em>) ∨ <em>Q</em>(<em>x</em>)</span>： <span class="math inline"><em>P</em>(<em>x</em>)</span>または<span class="math inline"><em>Q</em>(<em>x</em>)</span></p></li>
<li><p><span class="math inline"><em>P</em>(<em>x</em>) ∧ <em>Q</em>(<em>x</em>)</span>：P(x)かつQ(x)</p></li>
<li><p><span class="math inline"><em>p</em>(<em>x</em>) ⇒ <em>q</em>(<em>x</em>)</span>：<span class="math inline"><em>p</em>(<em>x</em>)</span>ならば<span class="math inline"><em>q</em>(<em>x</em>)</span></p></li>
<li><p><span class="math inline"><em>p</em>(<em>x</em>) ⇔ <em>q</em>(<em>x</em>)∶</span> <span class="math inline"><em>p</em>(<em>x</em>)</span>ならば <span class="math inline"><em>q</em>(<em>x</em>)</span> かつ <span class="math inline"><em>q</em>(<em>x</em>)</span> ならば <span class="math inline"><em>p</em>(<em>x</em>)</span></p></li>
<li><p>$ p(x):p(x)$ の否定</p></li>
</ul>
<p>なお, <span class="math inline"><em>p</em>(<em>x</em>) ⇒ <em>q</em>(<em>x</em>) ⇔ ¬<em>p</em>(<em>x</em>) ∨ <em>q</em>(<em>x</em>)</span></p>
<h3 id="集合">集合</h3>
<p>Haskellではデータ型を集合と<strong>みなすこと</strong>ができます(むしろ良く議論されるのは集合の圏 <strong><span class="math inline">𝕊𝕖𝕥</span></strong>
ですが,集合論の範囲でしばらく話しを進めます). Haskellの型はあくまで型であり,厳密には集合ではありません. また,このあと出てくるリストを使った<code>内包表記</code>などの<strong>集合論的な書き方</strong>も数学における集合ではありません.
あくまで類似したものです.</p>
<p>しかし,Haskellを集合とみなすことで,関数型プログラミングや,代数的データ型の意味がより直感的に理解できるようになります. しばらく,集合論とHaskellの対応について考えてみましょう.</p>
<div class="note">
<p>特定のモノがそこに｢属するか判定可能なモノの集まり｣を｢集合｣という．</p>
</div>
<p>集合の細かな定義は置いておいて,この講義では取り敢えずこのくらいの認識で問題ありません. しかし,ただのモノの集まりではなく,特定のモノがそこに属するかどうかを判定できる必要があるので注意が必要です.</p>
<p>例えば, ｢頭の良い人の集合｣のようなものは,｢頭が良い基準｣が人によって異なるので,集合とはみなせません.</p>
<p>ノーベル賞受賞者の集合,フィールズ賞受賞者の集合,メンサ会員の集合,XX模試の偏差値が70以上の人の集合,特定の科目で85点以上取った人の集合,など,誰でも判別可能な定義が必要です.</p>
<p>私が過去に飼ったことのある犬の種類の集合を<code>MyDogs</code>という名前で呼ぶと,<code>MyDogs</code>に属するモノたちを<code>{ }</code>を使って以下のように書くことができます.</p>
<p></p>
<p>このとき,<code>GoldenRetriever</code>や,<code>ShetlandSheepdog</code>は<code>MyDogs</code>の<code>要素</code>であるといい,要素が特定の集合に属するとき,</p>
<p><span class="math display"><em>G</em><em>o</em><em>l</em><em>d</em><em>e</em><em>n</em><em>R</em><em>e</em><em>t</em><em>r</em><em>i</em><em>e</em><em>v</em><em>e</em><em>r</em> ∈ <em>M</em><em>y</em><em>D</em><em>o</em><em>g</em><em>s</em></span> の様に書きます. 要素に属さないことは <span class="math inline"><em>C</em><em>h</em><em>i</em><em>h</em><em>u</em><em>a</em><em>h</em><em>u</em><em>a</em> ∉ <em>M</em><em>y</em><em>D</em><em>o</em><em>g</em><em>s</em></span>と書きます.</p>
<p>Haskellにおいて,このようなデータ型を以下の様に定義することが可能です.
データ型の宣言は, <code>data</code>のあとに続いて,<code>データ型の名前(型構築子)</code>を書き,<code>=</code>の後ろにその<code>中身(コンストラクタ/データ構築子)</code>を書きます.
型構築子やデータ構築子は,大文字の英字で始めるのが規則です.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyDogs</span> <span class="ot">=</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">BlackRetriever</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">ShetlandSheepdog</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">StandardPoodle</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">StandardPoodle</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
<p>この様にそこに属する要素をすべて書き出す(列挙する)データ型を<code>列挙型</code>といいます.</p>
<div class="warn">
<p>ちなみに,大文字の英字で始まってさえいればUTF-8の文字や絵文字,記号は使用できるので,以下のような記述も可能ですが,あまりおすすめしません.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">My</span>🐶   <span class="ot">=</span> <span class="dt">P</span>ゴールデンレトリーバー</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">P</span>ブラックレトリーバー</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">P</span>シェットランドシープドッグ</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">P</span>スタンダードプードル</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="dt">P</span>ビーグル</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
</div>
<p><code>deriving Show</code>はコンストラクタを文字列に変換する関する<code>show</code>を自動で導入するための記法です. 自分で定義することも可能ですが,詳細に関しては後ほど扱います.</p>
<p><code>deriving Show</code>を入れていない状態で</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="dt">GoldenRetriever</span></span></code></pre></div>
<p>などを実行すると,以下のエラーがでますが,<code>deriving Show</code>を追加することで,表示することが可能となります.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>{</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> <span class="kw">data</span> <span class="dt">MyDogs</span> <span class="ot">=</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span>             <span class="op">|</span> <span class="dt">BlackRetriever</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> <span class="op">:</span>}</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">17</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span> [<span class="dt">GHC</span><span class="op">-</span><span class="dv">39999</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">No</span> <span class="kw">instance</span> for ‘<span class="dt">Show</span> <span class="dt">MyDogs</span>’ arising from a use <span class="kw">of</span> ‘print’</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> <span class="fu">print</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> <span class="fu">print</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>{</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> <span class="kw">data</span> <span class="dt">MyDogs</span> <span class="ot">=</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span>             <span class="op">|</span> <span class="dt">BlackRetriever</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span>             <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> <span class="op">:</span>}</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="fu">print</span> <span class="dt">GoldenRetriever</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="dt">GoldenRetriever</span></span></code></pre></div>
<p>なお, <code>print</code>の<a href="https://hackage.haskell.org/package/base-4.19.1.0/docs/src/System.IO.html#print">実装</a>は</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span><span class="ot"> ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> x <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> x)</span></code></pre></div>
<p>となっています.</p>
<p>要素が一つも属さない集合を<code>空集合</code>といい,記号<span class="math inline"><em>ϕ</em></span> または<span class="math inline">｛｝</span>によって表されます．
Haskellでは空集合を表すデータ型として<code>Data.Void</code>に定義された<code>Void</code>が存在します. データ型として<code>ボトム型</code>,記号では<code>⊥</code>で表される場合もあります.</p>
<p><code>Void</code>と同じ値を持たないデータ型は,コンストラクタを記述しないことで自分で実装することもできます. 例えば私が犬を今までに一匹もかったことがなければ, <span class="math display"><em>M</em><em>y</em><em>P</em><em>e</em><em>t</em> = <em>ϕ</em></span> となり,データ型としては以下のように定義されます. 値が存在しない空集合と対応していることが分かります.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mypet</span></span></code></pre></div>
<p><code>Void</code>型は値が存在しないため実行することはできませんが,コンパイルを通すことはできます. ただし,あまり実用する機会はないので,以下の部分は興味がある人だけ開いて読んでください.</p>
<div class="note">
<ul>
<li>Voidの利用例 開く/閉じる</li>
</ul>
<p><code>Void</code>型を利用したコードを記述する方法はいくつかありますが, <code>undefined</code>した実装などが良く用いられます.
<code>undefined</code>は遅延評価を利用した値で,具体的な値や式の記述を省略することができます.
未実装の部分を含めたコードを取り敢えず部分的にコンパイルしてみたい場合や, エラー処理などで利用されます.</p>
<p>以下のコードはコンパイルは通りますが,実行時には<code>undefined, called</code>エラーが発生します.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">somFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>someFunc <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span></span></code></pre></div>
<p><code>Void</code>型を利用するケースは非常に限定的ですが,値が無いことを明示的に示したい場合などに利用されます.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE EmptyCase #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE EmptyDataDeriving #-}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Empty</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="ot">head' ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Empty</span> <span class="ot">-&gt;</span>  a</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>head' []     e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>head' (x<span class="op">:</span>[]) _ <span class="ot">=</span> x</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>head' (x<span class="op">:</span>xs) _ <span class="ot">=</span> x</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> head' ([]<span class="ot">::</span>[<span class="dt">Int</span>]) <span class="fu">undefined</span> <span class="co">-- &gt;&gt;&gt; undefined, called at</span></span></code></pre></div>
<p>このコードでは, 明示的に<code>先頭の値</code>が存在しないことを<code>Empty</code>で表し,<code>EmptyDataDeriving</code>拡張で<code>undefined</code>を評価することでエラーを発生させています.</p>
<p>しかし,こういったパターンでは,以下の<code>error</code>による実装や,後に説明する<code>Maybe型</code>を利用するほうが一般的です.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">head'' ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span>  a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>head'' []     <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Empty List&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>head'' (x<span class="op">:</span>[]) <span class="ot">=</span> x</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>head'' (x<span class="op">:</span>xs) <span class="ot">=</span> x</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> head'' ([]<span class="ot">::</span>[<span class="dt">Int</span>]) <span class="co">-- practice: Empty List error, called at</span></span></code></pre></div>
</div>
<p>単一の要素だけが存在するデータ型として<code>Unit</code>型も準備されており,<code>()</code>のような空のタプルとして表されます.</p>
<p>集合の表記法には，外延的表記及び内包的表記という2通りが存在する．外延的表記とは，集合Sに含まれる要素を全て記述する方法で，x,yを要素とする集合を，
S={x,y}
と書く．集合には順番は関係ないため，{x,y}={y,z}である．また，一つの集合に同じ要素は2つ以上属することができず，{x,x}のような集合は定義できない．</p>
<p>内包的表記とは，その集合に何が属するのかを定義する方法で集合Sに属する要素の集合をｘとすると，ｘがどの集合の要素であるか，どのような条件を持つかなどによって表記する．xの属する集合をX，条件式p(x)とすると，内包的表記では
S={x│x∈ X,p(x)}
と書かれる．また，内包表記において，関数や定数を定義することも許されており，
関数をf[x]で表すと，
S={f(x)|x∈X,f(x)=x+1}
のように表記される．
条件の例として，R<sup>+を非負の実数としたとき，R</sup>+５以下の非負の実数を，以下のように書く．
{x|x∈R^+,x≤5}
集合には，集合が属することも可能で，集合SがTに属するときS∈ Tが成り立つ．
また，集合Sの要素を幾つか取り出した集合TをSの部分集合といい，
T⊂S
と表記される．
S={x,y,z}のとき，Sの部分集合は
{x},{x,y},{x,z},{z,y},{x,y,z},ϕ
となる．任意の集合Sに対して
ϕ⊂S
は成り立つ．
また，集合Sの部分集合全体の集合を冪集合といい，pow[S]または2^S と書く．
pow[{x,y,z}]={{x},{x,y},{x,z},{z,y},{x,y,z},ϕ}</p>
<h3 id="型注釈と関数">型注釈と関数</h3>
<h4 id="内包表記">内包表記</h4>
<h3 id="包含">包含</h3>
<h3 id="積と和">積と和</h3>
<h2 id="代数とクラス">代数とクラス</h2>
<h3 id="マグマ">マグマ</h3>
<h3 id="半群">半群</h3>
<h3 id="モノイド">モノイド</h3>
<h3 id="群">群</h3>
<h3 id="リスト">リスト</h3>
<h3 id="ツリー">ツリー</h3>
<h3 id="ネットワーク">ネットワーク</h3>
<h2 id="手続き型haskell">手続き型Haskell</h2>
<h2 id="圏論とhaskell">圏論とHaskell</h2>
<h2 id="発展会計プログラム">発展:会計プログラム</h2>
<p>yakagika</p>

<!-- 前後の章へのナビゲーション -->
<div class="chapter-navigation">
    <nav>
        
            <a class="nav-link prev" href="iap4.html">← Previous Chapter</a>
        
        
            <a class="nav-link next" href="iap6.html">Next Chapter →</a>
        
    </nav>
</div>

    <div style="clear: both"></div>

    <div id="footer">
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
    </div>
</div>


    <!-- GUID -->
    <div style="display: none">ce0f13b2-4a83-4c1c-b2b9-b6d18f4ee6d2</div>

    
    <!-- KaTeX JavaScript and auto-render extension -->
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\[", right: "\]", display: true},
            {left: "$", right: "$", display: false}
          ]
        });
      });
    </script>
    

    <!-- JavaScript TOC generator (only runs on lecture pages) -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      var tocContainer = document.getElementById('lecture-toc');
      if (!tocContainer) return;

      // メインコンテンツから h2, h3, h4 を抽出
      var content = document.querySelector('article') || document.getElementById('content') || document.body;
      var headings = content.querySelectorAll('h2, h3, h4');
      if (headings.length === 0) return;

      // 目次用のUL要素を作成
      var tocList = document.createElement('ul');

      // 章番号カウンタ (h2, h3, h4に対応して配列を用意)
      var chapterNumbers = [0, 0, 0];

      headings.forEach(function(heading) {
        if (heading.closest('li')) return;

        var level;
        switch (heading.tagName.toLowerCase()) {
          case 'h2': level = 0; break;
          case 'h3': level = 1; break;
          case 'h4': level = 2; break;
          default: return;
        }

        chapterNumbers[level]++;
        for (var i = level + 1; i < chapterNumbers.length; i++) {
          chapterNumbers[i] = 0;
        }

        var chapterNumberStr = chapterNumbers.slice(0, level + 1).join('.');
        if (!heading.id) {
          heading.id = heading.textContent.trim().replace(/\s+/g, '-').toLowerCase();
        }

        var li = document.createElement('li');
        li.classList.add('toc-level-' + (level + 1));

        var anchor = document.createElement('a');
        anchor.href = '#' + heading.id;
        anchor.textContent = chapterNumberStr + ' ' + heading.textContent;

        li.appendChild(anchor);
        tocList.appendChild(li);
      });

      tocContainer.appendChild(tocList);
    });
    </script>
     <script>
  document.addEventListener("DOMContentLoaded", function() {
    // すべての <pre><code> 要素を走査
    const codeBlocks = document.querySelectorAll('pre code');
    codeBlocks.forEach(function(codeBlock) {
      // 親<pre>要素を取得
      const pre = codeBlock.parentNode;

      // <pre> を相対配置にし、子要素を絶対配置できるようにする
      pre.style.position = 'relative';

      // コピーボタンを作成
      const copyButton = document.createElement('button');
      copyButton.textContent = 'Copy';
      // ボタンのデザインはCSSで指定するのが望ましいが、簡易的にスタイルを直接指定する例:
      copyButton.style.position = 'absolute';
      copyButton.style.top = '8px';
      copyButton.style.right = '8px';
      copyButton.style.backgroundColor = '#add8e6'; // 水色
      copyButton.style.color = '#fff';             // 白文字
      copyButton.style.border = 'none';
      copyButton.style.padding = '6px 10px';
      copyButton.style.borderRadius = '4px';
      copyButton.style.cursor = 'pointer';

      // クリックされたらクリップボードにコピー
      copyButton.addEventListener('click', function() {
        const codeText = codeBlock.innerText;
        navigator.clipboard.writeText(codeText).then(function() {
          copyButton.textContent = 'Copied!';
          setTimeout(function() {
            copyButton.textContent = 'Copy';
          }, 2000);
        }, function(err) {
          console.error('Failed to copy: ', err);
        });
      });

      // ボタンを <pre> の子要素として挿入
      pre.appendChild(copyButton);
    });
  });
  </script>
  <script>
    function toggleMenu() {
      var nav = document.getElementById('navigation');
      nav.classList.toggle('open');
    }
  </script>
  </body>
</html>