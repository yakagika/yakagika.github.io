<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yakagika - 代数プログラミング入門 Ch4 関数</title>

    <!-- Stylesheets. -->
    <link rel="stylesheet" type="text/css" href="../style.css?v=0">

    <!-- RSS. -->
    <link rel="alternate" type="application/rss+xml" title="yakagika" href="https://yakagika.github.io/rss.xml">

    <!-- Metadata. -->

    <meta name="keywords" content="yakagika Haskell ExchangeAlgebra">
    <meta name="description" content="Personal home page and blog of yakagika.">

    
    <!-- KaTeXのスタイルシートとJavaScriptのリンクを動的に挿入 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-wcIxkf4k558AjM3Yz3BBFQUbk/zgIYC2R0QpeeYb+TwlBVMrlgLqwRjRtGZiK7ww" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoBPJpTUs74ddyc4bFZSM1TVlQDA60VBbJS0oA934VSz82sBx1X7kSx2ATBDIyd" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <style>
      .katex-display {
        display: block;
        margin: 1em 0;
        text-align: center;
      }
      .katex .frac {
        vertical-align: baseline;
        -webkit-vertical-align: baseline;
      }
      .katex .sqrt {
        vertical-align: baseline;
        -webkit-vertical-align: baseline;
      }
      .katex .strut {
        height: 1em;
        -webkit-height: 1em;
      }
      .katex .base {
        font-family: 'KaTeX_Main', 'Arial', sans-serif;
      }
      @media screen and (-webkit-min-device-pixel-ratio:0) {
        .katex {
          line-height: normal !important;
        }
      }
      @media not all and (min-resolution: .001dpcm) {
        @supports (-webkit-appearance:none) {
          .katex {
            line-height: normal !important;
          }
        }
      }
    </style>
    

    
      <meta property="og:description" content="資料" />
    
  </head>

  <body>

    <!-- ハンバーガーメニューのボタン（小画面時に表示） -->
    <div class="hamburger" onclick="toggleMenu()">☰</div>

    <!-- ナビゲーションに drawer-menu クラスを付与 -->
    <div id="navigation" class="drawer-menu">
      <h1>Contents</h1>
      <a href="../">Home</a>
      <a href="../posts.html">Blog</a>
      <a href="../lectures.html">Lecture</a>
      <a href="../research.html">Research</a>
      <a href="../contact.html">Contact</a>
      <!-- <a href="/cv.html">CV</a> -->

      <h1>Links</h1>
      <a href="http://github.com/yakagika" target="_blank" rel="noopener">GitHub</a>
      <a href="https://researchmap.jp/k-akagi" target="_blank" rel="noopener">researchmap</a>

      
      <div id="lecture-toc">
        <h1>Table of Contents</h1>
        <!-- The TOC will be generated here by JavaScript -->
      </div>
      
    </div>

    <div id="content">
    <h1>代数プログラミング入門 Ch4 関数</h1>
<div class="soft">
    資料<br />
    Published on 2024-10-18 under the tag <a title="All pages tagged 'algebra'." href="../tags/algebra.html">algebra</a>, <a title="All pages tagged 'lecture'." href="../tags/lecture.html">lecture</a>, <a title="All pages tagged 'haskell'." href="../tags/haskell.html">haskell</a>
</div>

<!-- 前後の章へのナビゲーション -->
<div class="chapter-navigation">
    <nav>
        
            <a class="nav-link prev" href="iap3.html">← Previous Chapter</a>
        
        
            <a class="nav-link next" href="iap5.html">Next Chapter →</a>
        
    </nav>
</div>

<br>

<h2 id="関数">関数</h2>
<p>Haskellは関数型言語なので,関数の記述がプログラミングにおける花形です. この章ではHaskellの関数に関する記法を学びましょう.</p>
<h3 id="関数と演算子">関数と演算子</h3>
<p>関数型言語では関数を組み合わせてプログラムを書きます. 関数の正確な定義は後に譲るとして,ここでは取り敢えず｢特定のデータ型の値を受け取って,特定のデータ型の値を返すもの｣という定義にしましょう.このとき受け取る値を<strong>引数</strong>,返す値を<strong>返り値</strong>といいます.</p>
<p>Haskellでは,数学の記法と非常に近い方法で関数を定義します.
例えば,</p>
<p><span class="math display">$$
f : \mathbb{Z} \rightarrow \mathbb{Z} \\
f(x) = x + 1
$$</span></p>
<p>という,整数<code>x</code>を受け取って整数<code>x + 1</code>を返すだけの関数について考えましょう.</p>
<p>Haskellでは上の関数は以下のように定義されます.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> f <span class="dv">4</span> <span class="co">--  5</span></span></code></pre></div>
<p><code>()</code>の代わりにスペースを使う点以外は全く同じ書き方で, <code>=</code>の左側に関数名と引数,右側に返り値を書きます.
関数名は小文字の英字で始めるというルールがあります.</p>
<p><code>f :: Int -&gt; Int</code>は型注釈であり,この<code>f</code>という関数が,引数に<code>Int</code>を取り,返り値として<code>Int</code>を返すということを指定しています.
型注釈は高度な処理をしない限り省略しても自動的にGHCが推論してくれますが,可読性のためにもできるだけ書くようにしましょう.</p>
<p><code>do</code>以下の記述で, <code>f 4</code>の結果を確認しています. <code>print</code>は,文字列に変換可能な値を受け取り,標準出力する関数です. また <code>(f 4)</code>を省略して<code>$ f 4</code> としています.</p>
<p>引数は何個でも利用できます. 例えば2引数関数</p>
<p><span class="math display"><em>m</em><em>u</em><em>l</em><em>t</em><em>i</em><em>p</em><em>l</em><em>e</em>(<em>x</em>,<em>y</em>) = <em>x</em> * <em>y</em></span></p>
<p>は以下のように定義できます.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">multiple ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>multiple x y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>multiple <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> multiple <span class="dv">3</span> <span class="dv">4</span> <span class="co">--  12.0</span></span></code></pre></div>
<p>また,以下の記号を組み合わせて中置演算子名として利用することも可能です.</p>
<div class="note">
<p>~ ! # $ % &amp; * + = . / &lt; &gt; ? @   ^ | -</p>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">.*</span> y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="dv">3</span> <span class="op">.*</span> <span class="dv">4</span> <span class="co">--  12.0</span></span></code></pre></div>
<p>絵文字などのUnicode記号も利用することができます.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>(✖)<span class="ot"> ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>x ✖ y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="dv">3</span> ✖ <span class="dv">4</span> <span class="co">--  12.0</span></span></code></pre></div>
<p>記号を利用して関数を定義する場合には,定義時に<code>()</code> で囲うことで一般の関数のように定義することができます.
例えば, 乗算を新たに定義するとして,以下のように書くことができます.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.*) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">.*</span>) x y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="dv">3</span> <span class="op">.*</span> <span class="dv">4</span> <span class="co">--  12</span></span></code></pre></div>
<p>前置の2引数関数も<code>``</code> (バッククオート)で囲むことで中置演算子として定義することができます.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`multiple`</span> y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="dv">3</span> <span class="ot">`multiple `</span> <span class="dv">4</span> <span class="co">--  12</span></span></code></pre></div>
<h4 id="結合性">結合性</h4>
<p>先に述べたように異なる複数の演算子が連なっている式は, 演算子の優先順位に従って計算される順位が変わります.</p>
<p>例えば,<code>*</code> の優先順位は7で, <code>+</code> の優先順位は6なので,<code>2 * 3 + 3</code> という式は,</p>
<pre><code>   2 * 3  + 3
= (2 * 3) + 3
= 6 + 3
= 9</code></pre>
<p>と言う風に<code>*</code>が優先して計算されます.</p>
<p>では,同じ演算子が複数回連なっている場合にはどのような順序で計算されるのでしょうか? このルールを決めるのが <strong>結合性(Associativity)</strong> です.</p>
<div class="note">
<p>結合性には, <strong>左結合(Left-associative)</strong>, <strong>右結合(Right-associative)</strong>, <strong>非結合(Non-associative)</strong> の3種類があり,ユーザーが定義することができます.</p>
<ul>
<li><strong>左結合(Left-associative)</strong></li>
</ul>
<p>左結合の場合, 演算子は左から右へと評価されます. 例えば, <code>+</code> は左結合であり,式 <code>a + b + c</code> は <code>(a + b) + c</code> として評価されます</p>
<ul>
<li><strong>右結合(Right-associative)</strong></li>
</ul>
<p>右結合演算子の場合,演算子は右から左へと評価されます.例えば、<code>^</code>は右結合です。式 <code>a ^ b ^ c</code> は <code>a ^ (b ^ c)</code> として評価されます</p>
<ul>
<li><strong>非結合(Non-associative)</strong></li>
</ul>
<p>非結合演算子は,同じ式内で連続して使用することは許されていません. 非結合演算子の例としては,比較演算子（<code>&lt;</code>,<code>&gt;</code> など）があります.</p>
<p>式 <code>a &lt; b &lt; c</code> は Haskell では文法的に不正です. 比較を連鎖させる場合は,<code>a &lt; b &amp;&amp; b &lt; c</code>のように明確に分けて記述する必要があります.</p>
</div>
<p>ユーザーが作成した演算子の結合性を指定するには,右,左,非の順に<code>infixr</code>,<code>infixl</code>,<code>infix</code>宣言を利用します. いずれも, <code>infix(r/l/なし) 優先順位 記号</code> の順に書きます.</p>
<p>例えば先程作成した,<code>.*</code> を右結合の優先順位7で指定するには,以下のように書きます.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">.*</span> y <span class="ot">=</span> x <span class="op">*</span> y</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">7</span> <span class="op">.*</span></span></code></pre></div>
<h3 id="カリー化部分適用">カリー化,部分適用</h3>
<p>Haskellでは多引数関数を実装できることは先程確認しました. しかし,Haskellは<strong>すべての関数が,引数を一つだけとる</strong>という原則があります. これは,矛盾するようですが,この矛盾を解消する概念が<strong><code>カリー化(Currying)</code></strong>です.</p>
<p>カリー化とは複数引数関数に対して,｢一つの引数を取り,次に残りの引数を取る関数を返すようにする変換｣です.</p>
<p>例として,以下のxとyを受け取りその和を返す関数<code>add</code>は</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>実際には</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>として機能しています. 関数の呼び出しは左結合なので,</p>
<p><code>add 5 10 = (add 5) 10</code> であり, ここで<code>(add 5) :: Int -&gt; Int</code>という新たな関数に2が適用されています.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="op">&gt;</span> :{</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="kw">|</span> <span class="ex">add</span> :: Int <span class="at">-</span><span class="op">&gt;</span> Int <span class="at">-</span><span class="op">&gt;</span> Int</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="kw">|</span> <span class="ex">add</span> x y = x + y</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="kw">|</span> <span class="ex">:}</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="op">&gt;</span> :t add</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ex">add</span> :: Int <span class="at">-</span><span class="op">&gt;</span> Int <span class="at">-</span><span class="op">&gt;</span> Int</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="ex">ghci</span><span class="op">&gt;</span> :t <span class="er">(</span><span class="ex">add</span> 5<span class="kw">)</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="ex">add</span> 5<span class="kw">)</span> <span class="ex">::</span> Int <span class="at">-</span><span class="op">&gt;</span> Int</span></code></pre></div>
<p>Haskellでは,標準で全ての関数がカリー化されており,これによって関数の複数の引数のうち一部だけを与えて,残りの引数を持つ関数を生成する<strong><code>部分適用(Partial Application)</code></strong>が可能となっています.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- add関数を利用した部分適用</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">add5 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>add5 <span class="ot">=</span> add <span class="dv">5</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実際の利用例</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> add5 <span class="dv">10</span></span></code></pre></div>
<h3 id="分岐">分岐</h3>
<p>関数型言語において,手続き型言語におけるIF文に相当するのが<strong>パターンマッチ</strong>と<strong>指示関数(特性関数)</strong>です.</p>
<h4 id="パターンマッチ">パターンマッチ</h4>
<p>パターンマッチに近い概念は既にフィボナッチ数の漸化式として出てきています.フィボナッチ数の漸化式は,以下のように表されます.</p>
<div class="note">
<p><span class="math display">$$
F_0 = 1 \\
F_1 = 1 \\
F_n = F_{n-1} + F_{n-2} (n &gt;= 2)
$$</span></p>
</div>
<p>この関数はPythonでは,以下のようにif文による分岐で記述されるのが一般的です.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(x):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> x <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fib(x<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> f(x<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<p>これをHaskellでパターンマッチを利用して以下のように定義することができます.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fib (n <span class="op">-</span> <span class="dv">2</span>)</span></code></pre></div>
<p>このHaskellのコードは,</p>
<ul>
<li><p>関数<code>fib</code>の引数が<code>0</code>のときには返り値として<code>1</code>を返し,</p></li>
<li><p>関数<code>fib</code>の引数が<code>1</code>のときには返り値として<code>1</code>を返し,</p></li>
<li><p>関数<code>fib</code>の引数が<code>それ以外</code>のときには返り値として<code>fib (n - 1) + fib (n - 2)</code>を返します.</p></li>
</ul>
<p>この最後の<code>fib n = fib (n - 1) + fib (n - 2)</code>は再帰関数といって後ほど扱いますが,取り敢えず,特定の引数に対して特定の返り値を指定するこのような関数の記述方法を<strong>パターンマッチ</strong>といいます.</p>
<p>パターンマッチは,数値以外の引数に関しても適用可能であり,リストではリストの要素数に応じて使い分けることが多いです.</p>
<p>以下の,<code>strHead</code>関数は,リストの先頭の要素を文字列として表示する関数です.リストが空のときには<code>"Empty"</code>,要素が一つのときにはその要素,それ以外のときには先頭の要素を文字列にして返します.</p>
<p><code>show</code>の詳細は後ほど扱いますが,どの様に標準出力に表示するかを定めてあるデータ型を文字列に変換する関数です.</p>
<div class="warn">
<p><code>Show a =&gt;</code>の部分は任意のデータ型<code>a</code>が<code>show</code>を利用できるという制約を意味しており, <strong>型クラス制約</strong>といいます.
クラスの詳細に関しては後ほど扱います.</p>
</div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strHead ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>strHead []     <span class="ot">=</span> <span class="st">&quot;Empty&quot;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>strHead [x]    <span class="ot">=</span> <span class="fu">show</span> x</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>strHead (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">show</span> x</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> strHead [] <span class="co">--  &quot;Empty&quot;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> strHead [<span class="dv">3</span>,<span class="dv">4</span>] <span class="co">--  &quot;3&quot;</span></span></code></pre></div>
<p>パターンマッチはこのようにリスト<code>x:xs</code>の先頭部分<code>x</code>を指定するなどの利用法が可能です. 値の特定の部分を取得する用法として頻出なのがタプルを引数に取るパターンマッチです.</p>
<p>以下のコードは,3つ組のタプル<code>(x,y,z)</code>から指定した位置の値を取り出す関数<code>getFromTuple</code>です.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>getFromTuple (x,y,z) <span class="dv">0</span> <span class="ot">=</span> x</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>getFromTuple (x,y,z) <span class="dv">1</span> <span class="ot">=</span> y</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>getFromTuple (x,y,z) <span class="dv">2</span> <span class="ot">=</span> z</span></code></pre></div>
<p>このような用法は後に紹介する代数的データ型を扱う際にも頻出します.</p>
<h4 id="ガード">ガード</h4>
<p>数式における分岐は,指示関数を用いて行うこともできます.</p>
<div class="note">
<p><span class="math display">$$
fib(n) =
\begin{cases}
1, ~if~n = 0 \\
1, ~if~n = 1 \\
fib(n-1) + fib(n-2),~if~n &gt;=2
\end{cases}
$$</span></p>
</div>
<p>Haskellにおいて指示関数の記法に相当するのが<strong>ガード</strong>です.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>fib n <span class="op">|</span> n <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> n <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">2</span> <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">5</span> <span class="co">--  8</span></span></code></pre></div>
<p>特徴関数におけるifの位置が先に来ている以外は,基本的に対応関係にあるのがわかるかと思います.</p>
<h4 id="case式">case式</h4>
<p>パターンマッチをインデントブロックで実現する手法として<strong>case式</strong>があります. パターンマッチで判定する変数を<code>case 変数 of</code> のあとに指定して, それぞれのパターンとその結果を<code>-&gt;</code>でつなげる記法です. 指定のパターンに当てはまらないものすべて(これを<strong>ワイルドカード</strong>といいます)を指定するために<code>_</code>を利用します.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">5</span> <span class="co">--  8</span></span></code></pre></div>
<p>ワイルドカードはどのような値に対しても同じ値を返す関数を実装する場合などにも利用されます.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">return10 ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>return10 _ <span class="ot">=</span> <span class="dv">10</span></span></code></pre></div>
<h4 id="if式">if式</h4>
<p>Haskellにはifも存在します. <code>if 条件</code>に当てはまる場合の返り値を<code>then</code>で指定します. <code>else if</code> で条件を追加し, <code>else</code>でそれ以外のパターンを指定します. Pythonなどのif文と異なり,式なので<code>else</code>の場合の返り値も必ず指定する必要があります.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> fib <span class="dv">5</span> <span class="co">--  8</span></span></code></pre></div>
<p>Haskellではあまりif式は利用されませんが,
1行で書けるため,式の中で部分的に利用する場合に便利です.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">1</span> <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<h3 id="再帰">再帰</h3>
<p>Haskellにおいても<strong>for文に相当する記法は存在します</strong>が,基本的にループは<strong>再帰</strong>によって実装されます.
再帰とは関数内で自分自身を呼び出すことです. これまで何度も登場していた<code>fib</code>も再帰を利用していましたが,
もう少し細かく見てみましょう.</p>
<p>以下のPythonにおけるfor文を事例に考えてみましょう.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> total(xs):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> xs:</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>        result <span class="op">+=</span> x</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<p>これと同値なプログラムをHaskellで記述すると以下のようになります.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">total ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>total []  <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>total [x] <span class="ot">=</span> x</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>total (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="op">+</span> (total xs)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> tatal [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] <span class="co">--  55</span></span></code></pre></div>
<p>このtotal関数は,与えられたリストが空の場合0を返し,要素が一つの場合その要素を返します.
要素が複数あるリストの場合には,先頭の要素<code>x</code>をそれ以降の要素<code>xs</code>の合計に足すという処理を行います.</p>
<p><code>total [1,2,3]</code>における処理の流れを追っていくと以下のようになります.</p>
<pre><code>total [1,2,3]
= 1 + (total [2,3])
= 1 + (2 + (total [3]))
= 1 + 2 + 3 + (total [])
= 1 + 2 + 3 + 0
= 6</code></pre>
<p>再帰の基本は,<strong>ループの終了状態</strong>をパターンマッチなどで指定して,そこに至るまでの状態の変化を再帰で記述することです.
処理がどのような状態になったら終わるのかを意識して記述しないと永遠に終了しないプログラムになるので注意しましょう.</p>
<div class="note">
<p>練習問題</p>
<ol type="1">
<li><p>リストの長さを返す<code>length2 :: [a] -&gt; Int</code> 関数を新しく実装してください.</p></li>
<li><p>与えられた整数のリストを引数にとり,要素毎にFizzBuzzを実行した結果を文字列のリストで返す関数
<code>fizzBuzz :: [Int] -&gt; [String]</code>実装してください.</p></li>
</ol>
</div>
<h3 id="高階関数">高階関数</h3>
<p>これまで扱ってきた関数の引数はすべて,値でしたが値ではなく<strong>関数</strong>を引数として指定することが可能です. <strong>関数を引数に取る関数を高階関数といいます</strong>.</p>
<p>例えば関数<code>f</code>とリスト<code>[x,y,z]</code>を引数として受け取り,リストの各要素に<code>f</code>を適用したリスト<code>[f x, f y, f z]</code>を返す関数は以下のように実装できます.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyFToList ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>applyFToList f []     <span class="ot">=</span> []</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>applyFToList f [x]    <span class="ot">=</span> [f x]</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>applyFToList f (x<span class="op">:</span>xs) <span class="ot">=</span>  (f x)<span class="op">:</span> (applyFToList f xs)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> applyFToList (<span class="dv">2</span><span class="op">*</span>) [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [8,10,12]</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> applyFToList (<span class="dv">1</span><span class="op">+</span>) [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [5,6,7]</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> applyFToList <span class="fu">show</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;]</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> applyFToList fib  [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [5,8,13]</span></span></code></pre></div>
<p>関数部分は, <code>(a -&gt; b)</code>のように,丸括弧で囲んでいます.</p>
<h4 id="map">map</h4>
<p>この関数と同じものが組み込み関数(あらかじめ定義された関数)として提供されている代表的な高階関数<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>です.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> (<span class="dv">2</span><span class="op">*</span>) [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [8,10,12]</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> (<span class="dv">1</span><span class="op">+</span>) [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [5,6,7]</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> <span class="fu">show</span> [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [&quot;4&quot;,&quot;5&quot;,&quot;6&quot;]</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">map</span> fib  [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]  <span class="co">-- [5,8,13]</span></span></code></pre></div>
<div class="warn">
<ul>
<li><h3 id="prelude">Prelude</h3>
Haskellの組み込み関数はライブラリ<code>Prelude</code>として提供されています.
<code>Prelude</code>はすべてのプロジェクトで自動で読み込まれています.</li>
</ul>
<p><code>map</code>関数は他のライブラリでも同名のものが提供されているため,それらと名前が被っている場合はどちらの<code>map</code>を利用するのか判別できないというエラーが起きます.</p>
<p>例として,<code>Data.Text</code>も<code>map</code>を提供しているために,<code>Data.Text</code>を<code>import</code>している場合には以下のようなエラーが出ます.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Ambiguous</span> occurrence ‘map’</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">It</span> could refer to</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>       <span class="ex">either</span> ‘Prelude.map’,</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>              <span class="ex">imported</span> from ‘Prelude’ at app/practice.hs:1:1</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>              <span class="kw">(</span><span class="ex">and</span> originally defined in ‘GHC.Base’<span class="kw">)</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>           <span class="ex">or</span> ‘Data.Text.map’,</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>              <span class="ex">imported</span> from ‘Data.Text’ at app/practice.hs:4:1-16</span></code></pre></div>
<p>同名の関数が複数のライブラリで定義されている場合は,<code>Prelude.map</code>など,どのライブラリの<code>map</code>であるかを明示するか,
<code>hiding</code>を利用して特定の関数のみを<code>import</code>対象から外します.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">hiding</span> (map)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- map 以外すべてをimport</span></span></code></pre></div>
<p>あるいは,利用する関数のみを明示的に<code>import</code>することも可能です.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">hiding</span> (<span class="dt">Text</span>,empty)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Text,emptyのみをimport</span></span></code></pre></div>
</div>
<p>以下, よく用いられる代表的な高階関数に関して紹介します.</p>
<h4 id="filter">filter</h4>
<p><code>filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>はリストの中から与えられた関数で判定される条件に合致するもののみを抽出する関数です.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (elem)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">filter</span> (<span class="dv">10</span> <span class="op">&lt;</span> ) [<span class="dv">5</span>,<span class="dv">10</span>,<span class="dv">15</span>,<span class="dv">20</span>] <span class="co">--  [15,20]</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">filter</span> (Data.Text.elem <span class="ch">'a'</span>) [<span class="st">&quot;cat&quot;</span>,<span class="st">&quot;dog&quot;</span>,<span class="st">&quot;bird&quot;</span>] <span class="co">--  [&quot;cat&quot;]</span></span></code></pre></div>
<h4 id="fold">fold</h4>
<p><code>foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</code>,</p>
<p><code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></p>
<p>は畳み込み関数です.<code>foldl</code>はリストの左端,<code>foldr</code>はリストの右端から値を一つずつ抜き出して,2引数関数によって一つの値に畳み込んでいきます.
リストのデータ構造的に基本的には<code>foldl</code>のほうが効率が良いので<code>foldl</code>が用いられます.</p>
<p>例として,</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">foldl</span> (<span class="op">+</span>) <span class="dv">0</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="co">--  6</span></span></code></pre></div>
<p>の挙動は,</p>
<p><code>foldl (+) 0 [1,2,3]</code></p>
<p><code>foldl (+) (0+1) [2,3]</code></p>
<p><code>foldl (+) (1+2) [3]</code></p>
<p><code>foldl (+) (3+3) []</code></p>
<p><code>6</code></p>
<p>となります.</p>
<h4 id="zipwith-zip">zipWith, zip</h4>
<p><code>zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>
<p>は2つのリストからそれぞれ値を順番に取り出して,関数を適用した結果をリストに格納する高階関数です.</p>
<p>例として.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">zipWith</span> (<span class="op">++</span>) [<span class="st">&quot;a&quot;</span>,<span class="st">&quot;b&quot;</span>,<span class="st">&quot;c&quot;</span>] [<span class="st">&quot;x&quot;</span>,<span class="st">&quot;y&quot;</span>,<span class="st">&quot;z&quot;</span>] <span class="co">--  [&quot;ax&quot;,&quot;by&quot;,&quot;cz&quot;]</span></span></code></pre></div>
<p>の挙動は,</p>
<p><code>zipWith (++) ["a","b","c"] ["x","y","z"]</code></p>
<p><code>["a" ++ "x" ,"b" ++ "y","c" ++ "z"]</code></p>
<p>となります.</p>
<p><code>zip :: [a] -&gt; [b] -&gt; [(a,b)]</code></p>
<p>は2つのリストからそれぞれ値を順番に取り出して,<code>[(左のリスト値,右のリストの値)]</code>を返す関数です.
タプルを返す2引数関数 <code>,</code> によって <code>zipWith (,)</code> として実装されます.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">zip' ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>zip' <span class="ot">=</span> <span class="fu">zipWith</span> (,)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a,b)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>tuple a b <span class="ot">=</span> (a,b)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="ot">zip'' ::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a,b)]</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>zip'' <span class="ot">=</span> <span class="fu">zipWith</span> tuple</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">zip</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>] <span class="co">--  [(1,11),(2,12),(3,13)]</span></span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> zip' [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>] <span class="co">--  [(1,11),(2,12),(3,13)]</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> zip'' [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>] <span class="co">--  [(1,11),(2,12),(3,13)]</span></span></code></pre></div>
<div class="note">
<ul>
<li><h3 id="練習問題">練習問題</h3></li>
<li>与えられた整数のリストの各要素を二乗する関数squareListを,mapを使って定義してください.</li>
</ul>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>squareList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="co">-- [1,4,9,16]</span></span></code></pre></div>
<ul>
<li>整数のリストの総積を計算する関数productListを,foldlを使って定義してください.</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>productList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="co">-- 24</span></span></code></pre></div>
<ul>
<li>2つのリストから,それぞれの要素の大きい方を選んで新しいリストを作る関数maxListを,zipWithを使って定義してください.</li>
</ul>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>maxList [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>] [<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">5</span>] <span class="co">-- [2,4,5]</span></span></code></pre></div>
</div>
<h3 id="無名関数ラムダ式">無名関数(ラムダ式)</h3>
<p>高階関数に与える関数はその場限りの利用となる場合が多いため,先程の<code>zipWith</code>と<code>tuple</code>によって<code>zip</code>を定義した例のように, いちいち別の関数名をつけることは手間が多くなり,コードも冗長になりがちです.
そのような場合に, 使い捨ての関数を定義する手法が,<strong>無名関数(ラムダ式) Lambda expression</strong>です.</p>
<p>ラムダ計算は<span class="math inline"><em>λ</em></span>を表す記号,<code>\</code>を用いて, <code>\ 引数 -&gt; 返り値</code>の形で式を定義できます.</p>
<p>例として,</p>
<p><code>f x y z = x + y + z</code> は</p>
<p><code>\ x y z -&gt; x + y + z</code> となります.</p>
<p><code>zipWith</code> の例は以下のようにも定義できます.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">zip</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>] <span class="co">-- [(1,11),(2,12),(3,13)]</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">zipWith</span> (\ x y <span class="ot">-&gt;</span> (x,y)) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>] <span class="co">--  [(1,11),(2,12),(3,13)]</span></span></code></pre></div>
<p>また,練習問題中の<code>maxList</code>は,以下のように定義できます.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> <span class="fu">zipWith</span> (\x y <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="op">&gt;</span> y <span class="kw">then</span> x <span class="kw">else</span> y)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">3</span>]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>                    [<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">5</span>] <span class="co">-- [2,4,5]</span></span></code></pre></div>
<div class="note">
<ul>
<li><h3 id="flip-と高階関数"><code>flip</code> と高階関数</h3></li>
</ul>
<p><code>flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>は,<strong>関数の引数の順番を入れ替える関数</strong>であり,以下のような挙動を示します.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> (,) <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="co">-- (&quot;a&quot;,&quot;b&quot;)</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> <span class="fu">flip</span> (,) <span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="co">-- (&quot;b&quot;,&quot;a&quot;)</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>   <span class="co">---</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> (<span class="op">&gt;</span>) <span class="dv">1</span> <span class="dv">2</span> <span class="co">-- False</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> <span class="fu">flip</span> (<span class="op">&gt;</span>) <span class="dv">1</span> <span class="dv">2</span> <span class="co">-- True</span></span></code></pre></div>
<p>高階関数にラムダ式を組み合わせたことで,記述が長くなった場合などには,<code>flip</code>で引数の関数とリストを入れ替え,<strong>手続き型言語における<code>for文</code>に近い記法</strong>を採用する場合があります.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> <span class="fu">flip</span> <span class="fu">map</span> [<span class="op">-</span><span class="dv">3</span> <span class="op">..</span> <span class="dv">3</span>]</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">$</span> \ x <span class="ot">-&gt;</span> <span class="kw">case</span> x <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">of</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- [0,0,0,1,1,1,1]</span></span></code></pre></div>
<p>このような<code>flip</code>,ラムダ式と<code>$</code>を組み合わせた記法は今後の<strong>状態系</strong>や<strong>モナド</strong>に関する議論などで頻出します.
また,このような書き方を前提とした<code>forM</code>,<code>forM_</code>などの関数も登場するので,頭の片隅に入れておいてください.</p>
</div>
<div class="note">
<ul>
<li><h3 id="練習問題-1">練習問題</h3></li>
<li>ラムダ式と高階関数を利用して,リストの各要素に3を加える関数addThreeを定義してください.</li>
</ul>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>addThree [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="co">-- [4,5,6]</span></span></code></pre></div>
<ul>
<li>ラムダ式と高階関数を利用して,整数のリストから偶数だけを取り出す関数onlyEvenを定義してください.</li>
</ul>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>onlyEven [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>] <span class="co">-- [2,4,6]</span></span></code></pre></div>
<ul>
<li>ラムダ式と高階関数を利用して,整数のリストに含まれる要素の絶対値の合計を求める関数sumAbsを定義してください.</li>
</ul>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>sumAbs [<span class="op">-</span><span class="dv">3</span>,<span class="dv">4</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>] <span class="co">-- 10</span></span></code></pre></div>
</div>
<h3 id="関数合成">関数合成</h3>
<p>数学において,2つの関数 <span class="math inline"><em>f</em>(<em>x</em>), <em>g</em>(<em>x</em>)</span>があるとき, <span class="math inline"><em>f</em>(<em>g</em>(<em>x</em>))</span>を合成関数と呼び, <span class="math display"><em>f</em> ∘ <em>g</em></span> とも書きます.
通常Haskellでも関数を合成する場合には,</p>
<p><code>f (g x)</code> あるいは <code>f $ g x</code> と書きますが,関数 <code>(.)</code>によって <code>(f . g) x</code> と書くことができます.
関数定義においては</p>
<p><code>h = f . g</code> のように定義することが可能です.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> <span class="dv">3</span> <span class="op">+</span> x</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実行例</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- f(g(x))</span></span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> f <span class="op">$</span> g <span class="dv">2</span> <span class="co">-- 10</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- \[f \circ  g \]</span></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> (f <span class="op">.</span> g) <span class="dv">2</span> <span class="co">-- 10</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- 定義</span></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> h <span class="ot">=</span> f <span class="op">.</span> g</span>
<span id="cb44-17"><a href="#cb44-17" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> h <span class="dv">2</span> <span class="co">-- 10</span></span></code></pre></div>
<p>:::</p>
<h2 id="変数値の束縛">変数(値の束縛)</h2>
<p>Pythonなどの言語では,特定の変数に値を代入することができます.例えば,以下の最大値を求めるプログラムでは,変数<code>m</code>に最初の中身はリストの最初の要素が代入された後,次々とより大きな変数が代入されていきます. <code>変数</code>は名前の通り,次々とその値を変更していきます.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>xs <span class="op">=</span> [<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">1</span>]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>m  <span class="op">=</span> xs[<span class="dv">0</span>]</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> xs[<span class="dv">1</span>:]:</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> x <span class="op">&gt;</span> m:</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> x</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max value:'</span>,m)</span></code></pre></div>
<p>一方でHaskellでは,変数に一度値を割り当てると,その変数の値を後から変更することができません. 変数に値を再代入するという操作が許されていないのです. この性質を<code>普遍性</code> （immutability）といいます. したがって,Haskellでは代入という言葉を使わず<code>束縛</code>といいます.
これは,通常の手続き型言語との大きな違いになります.</p>
<div class="warn">
<p>※1 値を変えられないなら｢変数じゃない｣じゃないという意見もありますが,数学において変数と呼ばれているものに近い概念だと考えましょう.</p>
<p>※2 実は後にでてくる<code>State</code>や<code>ST</code>などHaskellでも<code>再代入(破壊的代入)</code>を扱うことはできますが,特定の仕組みによって以下の純粋関数型言語の特徴を保っています.</p>
</div>
<p>例えば,以下のように一度値を束縛した変数に新しく変数を代入しようとすると<code>xという変数に複数の宣言をしている</code>というエラーが出ます(ghciでやる場合には,<code>:{ :}</code>を入れる必要があり余計にややこしいですね.すみません).</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">&gt;</span> <span class="op">:</span>{</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> x <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>ghci<span class="op">|</span> <span class="op">:</span>}</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Multiple</span> declarations <span class="kw">of</span> ‘x’</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Declared</span> at<span class="op">:</span> <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">4</span><span class="op">:</span><span class="dv">1</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">5</span><span class="op">:</span><span class="dv">1</span></span></code></pre></div>
<p>これは一見非常に不便なように感じられますが,これによって関数型プログラムでは,プログラムの安全性を高めています.</p>
<p>例えばPythonにおける以下のプログラムについて考えてみましょう.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>counter <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_plus(x):</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> counter</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    counter <span class="op">+=</span> x</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> counter</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count(<span class="dv">1</span>))  <span class="co"># 出力: 1</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count(<span class="dv">1</span>))  <span class="co"># 出力: 2</span></span></code></pre></div>
<p>このプログラムでは,<code>count()</code>関数に対して同じ引数1を与えているにもかかわらず,関数を呼び出すたびに,グローバル変数<code>counter</code>が変更されて,結果が変わります. 同じ関数を呼び出しても,結果が変わるために関数のみから,関数の挙動を把握することができません.</p>
<p>一方でHaskellでは,常に同じ関数は,同じ入力に対して,同じ返り値を返します. このような特性を<strong>参照透過性(Referential Transparency)</strong>と呼び,これによってプログラムの挙動を把握しやすくしています.</p>
<p>また,上記のPythonのプログラムは,関数を実行するたびに,関数の外にある,<code>counter</code>という変数の状態が変化しています. このような,関数が実行されることで単に値を返す以外に何らかの｢外部の状態を変化させる｣ことを関数の<strong>副作用(Side Effect)</strong>といいます. これは言い換えれば,関数の実行によるプログラム全体への影響が,関数以外の外部の状態に依存していることを意味しており,プログラムの挙動を予測することを難しくします.</p>
<p>参照透過性と副作用は相互に結びついた概念ですが,Haskellでは参照透過性を保ち,副作用を排除するようにプログラムが設計されています.
このように, <strong>｢参照透過性｣</strong> と <strong>｢副作用の排除｣</strong> の両方を持った関数型言語を <strong>純粋関数型言語</strong> と呼びHaskellの大きな特徴の一つです.</p>
<p>Haskellにおいて,変数への再代入が禁止されていることのメリットは理解していただけたかと思いますが,Haskellにも変数自体はあります.</p>
<p>Haskellにおける変数は主に,<strong>トップレベル変数</strong>及び<strong>ローカル変数</strong>に大別されます.</p>
<h3 id="トップレベル変数">トップレベル変数</h3>
<p>先程の <code>x=1</code>のように,独立して宣言される変数を<code>トップレベル変数</code>と呼びます. トップレベル変数は,Pythonなどの言語における<code>グローバル変数</code>と同様に,スクリプト内のどこ場所からでも利用することができます.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>someFunc y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span> <span class="co">--  2</span></span></code></pre></div>
<h3 id="ローカル変数">ローカル変数</h3>
<p>手続き型言語においてスコープが制限された変数のように,特定の関数内でのみ参照可能な局所変数として,<strong>ローカル変数</strong>が存在します. Haskellにおけるローカル変数は, <code>let式</code>,<code>where節</code>の2つのパターンが用意されています(ラムダ式内の引数も見方によってはローカル変数かもしれません.)</p>
<h4 id="let式">let式</h4>
<p>関数内で <code>let 宣言 in 式</code>の形式で局所変数を定義できます.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>someFunc y <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>           <span class="kw">in</span> x <span class="op">+</span> y</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span> <span class="co">--  2</span></span></code></pre></div>
<p>この変数<code>x</code>は別の関数内で参照することはできません.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>someFunc y <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>           <span class="kw">in</span> x <span class="op">+</span> y</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>someFunc2 y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc2 <span class="dv">1</span> <span class="co">--  Variable not in scope: x :: Int</span></span></code></pre></div>
<p>複数の宣言をひとまとめにすることも可能です.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>someFunc z <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>                 y <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>           <span class="kw">in</span> x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span> <span class="co">--  4</span></span></code></pre></div>
<p><code>Do</code>記法を利用すると<code>in</code>を省略することができます.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>someFunc z <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>        y <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span> <span class="co">--  4</span></span></code></pre></div>
<h4 id="where節">where節</h4>
<p>数式の直後にインデントをつけて<code>where 宣言</code>と書くことでも局所変数や局所関数を定義できます.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someFunc ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>someFunc z <span class="ot">=</span> f z</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>    f z <span class="ot">=</span> x <span class="op">+</span> y <span class="op">+</span> z</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> <span class="op">$</span> someFunc <span class="dv">1</span> <span class="co">--  4</span></span></code></pre></div>
<h2 id="練習問題関数総合">練習問題(関数総合)</h2>
<div class="note">
<h3 id="統計量">1. 統計量</h3>
<ul>
<li><p>与えられたリストの標本標準偏差<code>s</code>を計算する関数を実装してください.</p></li>
<li><p>与えられた2つのリストの積率相関係数<code>r</code>を計算する関数を実装してください.</p></li>
</ul>
<p>それぞれの定義は以下とします.</p>
<p><span class="math display">$$
s = \sqrt{\frac{\sum_{i=1}^{n}(x_i - \bar{x})^2}{n}}
$$</span>
<span class="math display">$$
r = \frac{\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})}{\sqrt{\sum_{i=1}^{n}(x_i - \bar{x})^2 \sum_{i=1}^{n}(y_i - \bar{y})^2}}
$$</span></p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実行例</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xs <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span> <span class="op">..</span> <span class="dv">5</span>]</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>      ys <span class="ot">=</span> [<span class="dv">5</span>, <span class="dv">4</span> <span class="op">..</span> <span class="dv">1</span>]</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;標準偏差: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (stddev xs) <span class="co">---  1.4142135623730951</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;相関係数: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (correlation xs ys) <span class="co">--- -0.9999999999999998</span></span></code></pre></div>
<details>
<summary>
回答例
</summary>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 平均値を求める関数\mean :: [Double] -&gt; Double</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>mean xs <span class="ot">=</span> <span class="fu">sum</span> xs <span class="op">/</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 標本標準偏差を求める関数</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="ot">stddev ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>stddev xs <span class="ot">=</span> <span class="fu">sqrt</span> variance</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>    m <span class="ot">=</span> mean xs</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">=</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>    variance <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">map</span> (\x <span class="ot">-&gt;</span> (x <span class="op">-</span> m)<span class="op">^</span><span class="dv">2</span>) xs) <span class="op">/</span> n</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- 積率相関係数を求める関数</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="ot">correlation ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>correlation xs ys <span class="ot">=</span> covariance <span class="op">/</span> (stddev xs <span class="op">*</span> stddev ys)</span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>    mx <span class="ot">=</span> mean xs</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>    my <span class="ot">=</span> mean ys</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a>    n  <span class="ot">=</span> <span class="fu">fromIntegral</span> (<span class="fu">length</span> xs)</span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a>    covariance <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">zipWith</span> (\x y <span class="ot">-&gt;</span> (x <span class="op">-</span> mx)<span class="op">*</span>(y <span class="op">-</span> my)) xs ys) <span class="op">/</span> n</span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実行例</span></span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xs <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span> <span class="op">..</span> <span class="dv">5</span>]</span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a>      ys <span class="ot">=</span> [<span class="dv">5</span>, <span class="dv">4</span> <span class="op">..</span> <span class="dv">1</span>]</span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;標準偏差: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (stddev xs) <span class="co">---  1.4142135623730951</span></span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;相関係数: &quot;</span> <span class="op">++</span> <span class="fu">show</span> (correlation xs ys) <span class="co">--- -0.9999999999999998</span></span></code></pre></div>
</details>
<h3 id="パーセプトロン">2. パーセプトロン</h3>
<ul>
<li>or 回路を表すパーセプトロンの発火関数 <code>f x1 x2</code> を以下のように定める.
(パーセプトロンの意味などがわからない場合は, <a href="slds14.html">特別講義資料</a>を参照のこと)</li>
</ul>
<p><span class="math display">$$
f(x1, x2) =
\begin{cases}
1 &amp; (0.5 x_1 + 0.5 x_2 \geq 0.2)\\
0 &amp; (\text{otherwise})
\end{cases}
$$</span></p>
<p>この回路を表す<code>perceptronOR :: Bool -&gt; Bool -&gt; Bool</code>を実装せよ.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実行例</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">False</span> <span class="dt">False</span> <span class="co">-- False</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">True</span> <span class="dt">False</span>  <span class="co">-- True</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">False</span> <span class="dt">True</span>  <span class="co">-- True</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">True</span> <span class="dt">True</span>   <span class="co">-- True</span></span></code></pre></div>
<details>
<summary>
回答例
</summary>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">perceptronOR ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>perceptronOR x1 x2</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">sum</span> <span class="op">&gt;=</span> <span class="dv">0</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    g <span class="dt">True</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>    g <span class="dt">False</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sum</span> <span class="ot">=</span> <span class="fl">0.5</span> <span class="op">*</span> g x1 <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> g x2 <span class="op">-</span> <span class="fl">0.2</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- 実行例</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">False</span> <span class="dt">False</span> <span class="co">-- False</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">True</span> <span class="dt">False</span>  <span class="co">-- True</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">False</span> <span class="dt">True</span>  <span class="co">-- True</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> <span class="op">$</span> perceptronOR <span class="dt">True</span> <span class="dt">True</span>   <span class="co">-- True</span></span></code></pre></div>
</details>
</div>

<!-- 前後の章へのナビゲーション -->
<div class="chapter-navigation">
    <nav>
        
            <a class="nav-link prev" href="iap3.html">← Previous Chapter</a>
        
        
            <a class="nav-link next" href="iap5.html">Next Chapter →</a>
        
    </nav>
</div>

    <div style="clear: both"></div>

    <div id="footer">
        Site proudly generated by
        <a href="http://jaspervdj.be/hakyll">Hakyll</a>.
    </div>
</div>


    <!-- GUID -->
    <div style="display: none">ce0f13b2-4a83-4c1c-b2b9-b6d18f4ee6d2</div>

    
    <!-- KaTeX JavaScript and auto-render extension -->
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\[", right: "\]", display: true},
            {left: "$", right: "$", display: false}
          ]
        });
      });
    </script>
    

    <!-- JavaScript TOC generator (only runs on lecture pages) -->
    <script>
    document.addEventListener("DOMContentLoaded", function() {
      var tocContainer = document.getElementById('lecture-toc');
      if (!tocContainer) return;

      // メインコンテンツから h2, h3, h4 を抽出
      var content = document.querySelector('article') || document.getElementById('content') || document.body;
      var headings = content.querySelectorAll('h2, h3, h4');
      if (headings.length === 0) return;

      // 目次用のUL要素を作成
      var tocList = document.createElement('ul');

      // 章番号カウンタ (h2, h3, h4に対応して配列を用意)
      var chapterNumbers = [0, 0, 0];

      headings.forEach(function(heading) {
        if (heading.closest('li')) return;

        var level;
        switch (heading.tagName.toLowerCase()) {
          case 'h2': level = 0; break;
          case 'h3': level = 1; break;
          case 'h4': level = 2; break;
          default: return;
        }

        chapterNumbers[level]++;
        for (var i = level + 1; i < chapterNumbers.length; i++) {
          chapterNumbers[i] = 0;
        }

        var chapterNumberStr = chapterNumbers.slice(0, level + 1).join('.');
        if (!heading.id) {
          heading.id = heading.textContent.trim().replace(/\s+/g, '-').toLowerCase();
        }

        var li = document.createElement('li');
        li.classList.add('toc-level-' + (level + 1));

        var anchor = document.createElement('a');
        anchor.href = '#' + heading.id;
        anchor.textContent = chapterNumberStr + ' ' + heading.textContent;

        li.appendChild(anchor);
        tocList.appendChild(li);
      });

      tocContainer.appendChild(tocList);
    });
    </script>
     <script>
  document.addEventListener("DOMContentLoaded", function() {
    // すべての <pre><code> 要素を走査
    const codeBlocks = document.querySelectorAll('pre code');
    codeBlocks.forEach(function(codeBlock) {
      // 親<pre>要素を取得
      const pre = codeBlock.parentNode;

      // <pre> を相対配置にし、子要素を絶対配置できるようにする
      pre.style.position = 'relative';

      // コピーボタンを作成
      const copyButton = document.createElement('button');
      copyButton.textContent = 'Copy';
      // ボタンのデザインはCSSで指定するのが望ましいが、簡易的にスタイルを直接指定する例:
      copyButton.style.position = 'absolute';
      copyButton.style.top = '8px';
      copyButton.style.right = '8px';
      copyButton.style.backgroundColor = '#add8e6'; // 水色
      copyButton.style.color = '#fff';             // 白文字
      copyButton.style.border = 'none';
      copyButton.style.padding = '6px 10px';
      copyButton.style.borderRadius = '4px';
      copyButton.style.cursor = 'pointer';

      // クリックされたらクリップボードにコピー
      copyButton.addEventListener('click', function() {
        const codeText = codeBlock.innerText;
        navigator.clipboard.writeText(codeText).then(function() {
          copyButton.textContent = 'Copied!';
          setTimeout(function() {
            copyButton.textContent = 'Copy';
          }, 2000);
        }, function(err) {
          console.error('Failed to copy: ', err);
        });
      });

      // ボタンを <pre> の子要素として挿入
      pre.appendChild(copyButton);
    });
  });
  </script>
  <script>
    function toggleMenu() {
      var nav = document.getElementById('navigation');
      nav.classList.toggle('open');
    }
  </script>
  </body>
</html>